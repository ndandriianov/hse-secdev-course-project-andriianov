# ADR-002: Нормализация дат и денег - UTC, Decimal, локаль

**Дата:** 2025-11-02
**Статус:** Accepted

## Context

В приложении используются даты/времена и денежные величины в разных компонентах (API, БД, отчёты, экспорт/импорт). Проблемы, которые наблюдаются в подобных системах и которые нужно предотвратить:

- Непоследовательность времён из-за разных часовых поясов -> ошибки в показателях, неверные отчёты и возможные утечки/несогласованности данных.
- Использование float для денег приводит к округлениям и арифметическим ошибкам (precision loss), влияющим на расчёты и отображение.
- Локаль (форматирование дат/денег) должна управляться на представлении, а не в доменной логике.
- Неканонизированные форматы при импорте/экспорте (CSV, JSON) создают ошибки и мешают автоматическому тестированию.

Требования/ограничения:
- Сохранять и передавать время в едином каноническом формате.
- Избежать использования типов с плавающей точкой для денежных значений в доменной логике.
- Обеспечить явную семантику локали и форматирования в слое представления (frontend/CLI).
- Сохранить совместимость с существующей БД (Postgres).

## Decision

Принято единное правило для работы с датами/временем и денежными величинами:

1) Времена (timestamps)
- Canonical storage/transport: все временные метки - в UTC в формате ISO 8601 с указанием Z (напр. 2025-09-22T14:23:00Z).
- На входе (API/импорт) - парсить входящие строки с распознаванием часового пояса; переводить в UTC и сохранять как timestamptz (Postgres) или как ISO-строку в JSON.
- В коде - использовать timezone-aware объекты (в Python: datetime.datetime с tzinfo=timezone.utc).
- При отображении пользователю - выполнять конвертацию в локальный часовой пояс на клиенте (или на сервере только если заранее договорено и явно указано).

Практические правила (Python):
- Всегда создавать datetime через datetime.now(tz=timezone.utc) или datetime.fromisoformat(...).astimezone(timezone.utc).
- Отсутствие tzinfo === ошибка; валидатор должен отклонять такие значения.

2) Деньги/числа с фиксированной точкой
- В доменной логике и БД использовать Decimal (Python: decimal.Decimal). Для хранения в Postgres использовать numeric/decimal с заданной точностью (scale/precision).
- Запрещено использовать float для денежных расчётов.
- Для сериализации в JSON использовать строковое представление или специализированные сериализаторы, которые явно контролируют scale; при передаче в API - строка (например, "1234.56") или объект { amount: "1234.56", currency: "USD" }.

Практические правила:
- Конфигурировать контекст Decimal: Decimal.getcontext().prec = 28 для вычислений, но не менять глобально без причины; предпочтительнее использовать локальные контексты (with localcontext()).
- Явно валидировать precision/scale при вводе (например, scale = 2 для валют с центовым представлением).
- При операциях деления использовать Decimal.quantize(...) с явной стратегией округления (ROUND_HALF_EVEN или банковское округление), документировать выбор.

3) Локаль и форматирование
- Локаль влияет только на представление (формат для пользователя): разделители тысяч/десятых, формат даты.
- Форматирование выполняется в слое презентации (frontend) или в API только если клиент запросил формат (через заголовок Accept-Locale) - в таком случае сервер выполняет форматирование на основании безопасных, контролируемых правил.
- Для вычислений и хранения - локаль не учитывается.

4) Импорт/экспорт
- Импортные конвейеры должны быть явными: указывать входную локаль/формат и валидировать.
- При обнаружении неоднозначных форматов (например, 01/02/2025) - отклонять с ошибкой и подсказкой о требуемом формате.

5) Валидация и контракт API
- В OpenAPI/схемах: datetime fields - format: date-time (ISO 8601), примечание: must be UTC (Z) на уровне описания.
- Money fields - формат string или объект с amount (string) + currency (ISO-4217).
- Добавить в тесты контракты, которые проверяют, что все внешние представления соответствуют этим правилам.

## Consequences

Плюсы:
- Устраняет ошибки, связанные с часовыми поясами и несогласованностью времён.
- Исключает float-ошибки и связанные с ними финансовые рассогласования.
- Улучшает воспроизводимость тестов и отчётности.
- Уменьшает риски, связанные с неверными расчётами (положительное влияние на доверие пользователей и на регуляторные требования).

Минусы / компромиссы:
- Дополнительный код для сериализации/десериализации Decimal и timezone-aware datetime.

Влияние на DX/производительность/стоимость:
- DX: небольшое повышение порога входа (нужно помнить о Decimal и timezone-aware datetime).
- Производительность: negligible; операции с Decimal чуть медленнее, но приемлемы для доменной логики.
- Стоимость: низкая - в основном трудозатраты на рефакторинг и тесты.

## Links

- NFR-1 (Время отклика API) - применимо: канонизация времени помогает при измерениях и SLA
- NFR-8 (Покрытие тестами) - требование писать тесты для контрактов даты/денег
- F1 (E1 -> P1 HTTPS), F10 (P3 -> D1 SQL/DB Write) - потоки, где данные даты/денег критичны
- R2 (RISKS.md) - Раскрытие чужих данных / горизонтальная авторизация: некорректные временные пересечения могут привести к ошибочным выдачам чужих данных (частично смягчается)
- R7 (RISKS.md) - Раскрытие внутренней структуры через информативные сообщения об ошибках: валидаторы должны давать безопасные сообщения при неправильных форматах
