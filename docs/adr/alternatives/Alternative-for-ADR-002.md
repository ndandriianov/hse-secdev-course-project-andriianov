## Alternative Decision — упрощённый подход для быстрого старта

Вместо строгой унификации со всеми деталями можно принять упрощённый и быстро реализуемый набор правил, который закроет основные ошибки (часы и float для денег) и минимизирует работу по внедрению:

Краткий упрощённый контракт:
- Времена: хранить и возвращать ISO 8601 строки с UTC-суффиксом (например, "2025-09-22T14:23:00Z"). На входе — парсить строки и пытаться привести к UTC; если вход не содержит часовой зоны - отклонять с ошибкой (простая валидация).
- Деньги: использовать Decimal в доменной логике и в БД (numeric). В API принимать/возвращать сумму как строку (например, "1234.56"). На начальном этапе запретить использование float в коде и в миграциях (проверяется ревью/CI).
- Локаль: полностью игнорировать в backend - форматирование по локали делать на frontend. Сервер только хранит канонический формат.

Минимальные шаги реализации:
1. Валидаторы в Pydantic: datetime поля - parse + require timezone либо reject; money поля - parse string → Decimal, reject floats.
2. DB: убедиться, что критичные поля используют numeric/decimal (миграция по необходимости).
3. JSON (быстрый): настроить encoder для Decimal → str.
4. Тесты: три простых теста:
   - datetime без зоны -> reject
   - datetime с зоной -> stored as UTC
   - money as float in input -> reject; money as string -> parse to Decimal

Плюсы:
- Очень быстро внедряется (низкий порог входа).
- Закрывает основные классы ошибок (плавающая точка для денег, неявные часовые пояса).
- Мало изменений в существующей инфраструктуре, легко покрыть тестами.

Минусы:
- Менее гибкий: отказ от поддержки импортов с локальными форматами без явной опции.
- Меньше дружелюбен к пользователям, которые присылают даты без зоны (строгие ошибки).
- Нужна явная документация для клиентов (что входы обязаны иметь Z/часовой пояс и суммы как строки).
